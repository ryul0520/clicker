<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>환생 클리커 v7: 최종 보스</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background-color: #1a1a1a; color: #f0f0f0; margin: 0; user-select: none; overflow: hidden; }
        #clicker-view { width: 1200px; margin: 20px auto; padding: 20px; background-color: #2a2a2a; border-radius: 10px; }
        header { text-align: center; margin-bottom: 20px; }
        header h1 { margin: 0; color: #e74c3c; }
        #main-content { display: flex; justify-content: space-between; gap: 20px; }
        .section { border: 1px solid #555; border-radius: 8px; padding: 15px; flex-basis: 32%; background-color: #333; }
        .section h2 { margin-top: 0; color: #eee; text-align: center; }
        #main-clicker-css { width: 150px; height: 150px; background: radial-gradient(circle, #ff5e5e 0%, #c0392b 100%); border-radius: 50%; margin: 10px auto; cursor: pointer; position: relative; box-shadow: 0 5px 10px rgba(0,0,0,0.4), inset 0 0 15px rgba(255,255,255,0.5); border: 5px solid #7b241c; }
        #main-clicker-css:active { transform: scale(0.95); }
        .stats p { font-size: 1.1em; }
        .stats .money-stat span { font-weight: bold; color: #f1c40f; }
        .stats .soul-stat span { font-weight: bold; color: #9b59b6; }
        .shop-tabs { display: flex; border-bottom: 1px solid #555; margin-bottom: 10px; }
        .shop-tab { padding: 10px; cursor: pointer; border-radius: 5px 5px 0 0; }
        .shop-tab.active { background: #444; }
        .shop-content { display: none; } .shop-content.active { display: block; }
        .shop-item { display: flex; justify-content: space-between; align-items: center; border: 1px solid #555; padding: 10px; margin-bottom: 10px; border-radius: 5px; }
        .shop-item button { padding: 8px 12px; cursor: pointer; color: white; border: none; border-radius: 3px; }
        .shop-item button.automation-btn { background: #2980b9; }
        .shop-item button.equipment-btn { background: #27ae60; }
        .shop-item button.soul-btn { background: #8e44ad; }
        .shop-item button:disabled { background: #7f8c8d; cursor: not-allowed; }
        #dungeon-entry-controls { text-align: center; margin-top: 20px; }
        #next-floor-display { font-size: 1.5em; font-weight: bold; color: #e67e22; }
        #enter-dungeon-btn { width: 100%; padding: 15px; font-size: 1.5em; font-weight: bold; background: #e67e22; color: white; border: none; border-radius: 8px; cursor: pointer; margin-top: 10px; }

        #dungeon-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; display: none; justify-content: center; align-items: center; }
        #dungeon-canvas { background: #1a1a1a; border: 2px solid #555; }
        #dungeon-ui { position: fixed; top: 20px; left: 20px; color: white; font-size: 1.2em; text-shadow: 2px 2px 4px #000; }
        #player-hp-bar-container { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); width: 300px; height: 30px; background: rgba(0,0,0,0.5); border: 2px solid #aaa; border-radius: 5px; }
        #player-hp-bar { width: 100%; height: 100%; background: #c0392b; transition: width 0.2s; }
        .dungeon-message-overlay { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; background: rgba(0,0,0,0.8); padding: 40px; border-radius: 10px; z-index: 100; }
        .dungeon-message-overlay h1 { font-size: 3em; margin: 0; }
        .dungeon-message-overlay p { font-size: 1.2em; }
        #death-message { color: #e74c3c; }
        #floor-clear-message { color: #2ecc71; }
        #continue-btn { padding: 10px 20px; font-size: 1.2em; margin-top: 20px; background: #27ae60; color: white; border: none; border-radius: 5px; cursor: pointer; }

        #virtual-controls { display: none; position: fixed; bottom: 0; left: 0; width: 100%; height: 100%; pointer-events: none; opacity: 0; transition: opacity 0.3s; }
        #virtual-controls.active { display: block; opacity: 1; }
        #joystick-base { position: absolute; bottom: 50px; left: 50px; width: 120px; height: 120px; background: rgba(128, 128, 128, 0.3); border-radius: 50%; pointer-events: all; }
        #joystick-stick { position: absolute; top: 35px; left: 35px; width: 50px; height: 50px; background: rgba(200, 200, 200, 0.5); border-radius: 50%; }
        #attack-button { position: absolute; bottom: 50px; right: 50px; width: 80px; height: 80px; background: rgba(231, 76, 60, 0.5); border: 2px solid rgba(231, 76, 60, 0.8); border-radius: 50%; pointer-events: all; display: flex; justify-content: center; align-items: center; font-size: 1.5em; color: white; }
        #attack-button:active { background: rgba(192, 57, 43, 0.8); }
    </style>
</head>
<body>
    <div id="clicker-view">
        <header><h1>환생 클리커</h1></header>
        <main id="main-content">
            <section class="section">
                <h2>자금 확보</h2>
                <div id="main-clicker-css"></div>
                <div class="stats">
                    <p class="money-stat">보유 금액: <span id="money-display">0</span> 원</p>
                    <p class="money-stat">초당 생산량(DPS): <span id="dps-display">0</span></p>
                    <p class="soul-stat">보유 영혼: <span id="soul-display">0</span> 개</p>
                    <p class="soul-stat">보스 심장: <span id="boss-heart-display">0</span> 개</p>
                </div>
            </section>
            <section class="section">
                <h2>상점</h2>
                <div class="shop-tabs">
                    <div class="shop-tab active" data-tab="automation">자동화</div>
                    <div class="shop-tab" data-tab="equipment">장비</div>
                    <div class="shop-tab" data-tab="soul">영혼 상점</div>
                </div>
                <div id="automation-shop" class="shop-content active"></div>
                <div id="equipment-shop" class="shop-content"></div>
                <div id="soul-shop" class="shop-content"></div>
            </section>
            <section class="section">
                <h2>탐험</h2>
                <p>던전에 입장하여 부와 명예를 얻으세요. 죽으면 모든 것을 잃고 환생하게 됩니다.</p>
                <div id="dungeon-entry-controls">
                    <p>도전할 층: <span id="next-floor-display">1층</span></p>
                    <button id="enter-dungeon-btn">던전 입장</button>
                </div>
            </section>
        </main>
    </div>

    <div id="dungeon-overlay">
        <canvas id="dungeon-canvas" width="800" height="600"></canvas>
        <div id="dungeon-ui">
            <div>층: <span id="floor-display">1</span></div>
            <div>획득 금액: <span id="loot-display">0</span></div>
        </div>
        <div id="player-hp-bar-container"><div id="player-hp-bar"></div></div>
        <div id="death-message" class="dungeon-message-overlay">
            <h1>YOU DIED</h1>
            <p>획득한 영혼: <span id="earned-soul-display">0</span></p>
            <p>3초 후 마을로 돌아갑니다...</p>
        </div>
        <div id="floor-clear-message" class="dungeon-message-overlay">
            <h1>CLEAR!</h1>
            <p>획득한 금액: <span id="clear-loot-display">0</span></p>
            <button id="continue-btn">마을로 귀환</button>
        </div>
        <div id="virtual-controls">
            <div id="joystick-base"><div id="joystick-stick"></div></div>
            <div id="attack-button">⚔️</div>
        </div>
    </div>

<script>
const game = {
    state: {
        clicker: { money: 0, upgrades: [], equipment: {} },
        permanent: { soul: 0, nextFloorToChallenge: 1, bossHearts: 0, upgrades: [] },
        dungeon: {
            isActive: false, isFloorCleared: false, isBossFloor: false, floor: 1, loot: 0, keys: {},
            player: {}, enemies: [], projectiles: [], hazards: [], loopId: null,
            touch: { joystickId: null, attackId: null, joystickBasePos: {x:0, y:0}, joystickMaxDist: 40 }
        }
    },
    elements: {}, ctx: null,

    init() {
        this.resetTemporaryState(true); this.cacheElements();
        this.ctx = this.elements.canvas.getContext('2d');
        this.loadGame(); this.buildShops(); this.addEventListeners();
        setInterval(() => this.runAutoProduction(), 100); this.updateAllDisplays();
    },
    
    resetTemporaryState(isFirstLoad = false) {
        this.state.clicker.money = 0;
        this.state.clicker.upgrades = [
            { id: 'worker', name: '알바생', level: 0, baseCost: 15, cost: 15, dps: 1 },
            { id: 'machine', name: '코인 기계', level: 0, baseCost: 120, cost: 120, dps: 8 },
            { id: 'factory', name: '코인 공장', level: 0, baseCost: 1300, cost: 1300, dps: 50 },
            { id: 'corp', name: '대기업', level: 0, baseCost: 15000, cost: 15000, dps: 280 },
            { id: 'bank', name: '중앙 은행', level: 0, baseCost: 180000, cost: 180000, dps: 1500 },
            { id: 'mint', name: '조폐국', level: 0, baseCost: 2000000, cost: 2000000, dps: 8000 },
            { id: 'planet', name: '행성 채굴', level: 0, baseCost: 25000000, cost: 25000000, dps: 50000 },
        ];
        this.state.clicker.equipment = {
            weapon: { name: '낡은 검', level: 1, baseCost: 50, cost: 50, attack: 5 },
            armor: { name: '가죽 갑옷', level: 1, baseCost: 50, cost: 50, maxHp: 100 },
            boots: { name: '낡은 신발', level: 1, baseCost: 75, cost: 75, speed: 3 }
        };
        if (isFirstLoad) {
            this.state.permanent.upgrades = [
                { id: 'soul-power', name: '영혼의 힘', level: 0, cost: 1, effect: 0.1, desc: "모든 DPS 10% 증가" },
                { id: 'starting-gold', name: '자본금', level: 0, cost: 2, effect: 100, desc: "시작 금액 +100원" },
                { id: 'warrior-spirit', name: '전사의 영혼', level: 0, cost: 5, effect: 0.3, desc: "던전 공격력 30% 증가" },
            ];
        }
    },

    cacheElements() {
        this.elements = {
            clickerView: document.getElementById('clicker-view'),
            moneyDisplay: document.getElementById('money-display'), dpsDisplay: document.getElementById('dps-display'),
            soulDisplay: document.getElementById('soul-display'), bossHeartDisplay: document.getElementById('boss-heart-display'),
            automationShop: document.getElementById('automation-shop'), equipmentShop: document.getElementById('equipment-shop'),
            soulShop: document.getElementById('soul-shop'), shopTabs: document.querySelectorAll('.shop-tab'),
            nextFloorDisplay: document.getElementById('next-floor-display'),
            enterDungeonBtn: document.getElementById('enter-dungeon-btn'),
            dungeonOverlay: document.getElementById('dungeon-overlay'), canvas: document.getElementById('dungeon-canvas'),
            floorDisplay: document.getElementById('floor-display'), lootDisplay: document.getElementById('loot-display'), 
            playerHpBar: document.getElementById('player-hp-bar'),
            deathMessage: document.getElementById('death-message'), earnedSoulDisplay: document.getElementById('earned-soul-display'),
            floorClearMessage: document.getElementById('floor-clear-message'),
            clearLootDisplay: document.getElementById('clear-loot-display'),
            continueBtn: document.getElementById('continue-btn'),
            virtualControls: document.getElementById('virtual-controls'), joystickBase: document.getElementById('joystick-base'),
            joystickStick: document.getElementById('joystick-stick'), attackButton: document.getElementById('attack-button'),
        };
    },

    buildShops() {
        this.elements.automationShop.innerHTML = '';
        this.state.clicker.upgrades.forEach(upg => this.elements.automationShop.innerHTML += this.createShopItemHTML(upg.id, upg.name, upg.level, upg.cost, `DPS: +${upg.dps}`, 'automation-btn'));
        this.elements.equipmentShop.innerHTML = '';
        const { weapon, armor, boots } = this.state.clicker.equipment;
        this.elements.equipmentShop.innerHTML += this.createShopItemHTML('weapon', weapon.name, weapon.level, weapon.cost, `공격력: ${weapon.attack}`, 'equipment-btn');
        this.elements.equipmentShop.innerHTML += this.createShopItemHTML('armor', armor.name, armor.level, armor.cost, `최대 HP: ${armor.maxHp}`, 'equipment-btn');
        this.elements.equipmentShop.innerHTML += this.createShopItemHTML('boots', boots.name, boots.level, boots.cost, `이동속도: ${boots.speed.toFixed(1)}`, 'equipment-btn');
        this.elements.soulShop.innerHTML = '';
        this.state.permanent.upgrades.forEach(upg => this.elements.soulShop.innerHTML += this.createShopItemHTML(upg.id, upg.name, upg.level, upg.cost, upg.desc, 'soul-btn'));
    },
    
    createShopItemHTML(id, name, level, cost, desc, btnClass) {
        return `<div class="shop-item" id="${id}-item"><div><strong>${name} (Lv.<span id="${id}-level">${level}</span>)</strong><br><small id="${id}-desc">${desc}</small> | <small>비용: <span id="${id}-cost">${cost.toLocaleString()}</span></small></div><button class="shop-btn ${btnClass}" data-id="${id}">구매</button></div>`;
    },

    addEventListeners() {
        document.getElementById('main-clicker-css').addEventListener('click', () => { this.state.clicker.money++; this.updateAllDisplays(); });
        this.elements.shopTabs.forEach(tab => tab.addEventListener('click', e => {
            document.querySelectorAll('.shop-tab, .shop-content').forEach(el => el.classList.remove('active'));
            e.target.classList.add('active'); document.getElementById(e.target.dataset.tab + '-shop').classList.add('active');
        }));
        document.querySelector('#automation-shop').addEventListener('click', e => this.buyUpgrade(e, 'automation'));
        document.querySelector('#equipment-shop').addEventListener('click', e => this.buyUpgrade(e, 'equipment'));
        document.querySelector('#soul-shop').addEventListener('click', e => this.buyUpgrade(e, 'soul'));
        this.elements.enterDungeonBtn.addEventListener('click', () => this.enterDungeon());
        this.elements.continueBtn.addEventListener('click', () => this.exitDungeonSafely());
        this.addVirtualControlsListeners();
    },

    addVirtualControlsListeners() {
        const { virtualControls } = this.elements;
        virtualControls.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
        virtualControls.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
        virtualControls.addEventListener('touchend', (e) => this.handleTouchEnd(e));
        virtualControls.addEventListener('touchcancel', (e) => this.handleTouchEnd(e));
    },

    handleTouchStart(e) {
        e.preventDefault(); const touchState = this.state.dungeon.touch;
        for (const touch of e.changedTouches) {
            if (touch.target === this.elements.joystickBase && touchState.joystickId === null) {
                touchState.joystickId = touch.identifier;
                const rect = this.elements.joystickBase.getBoundingClientRect();
                touchState.joystickBasePos = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
            } else if (touch.target === this.elements.attackButton && touchState.attackId === null) {
                touchState.attackId = touch.identifier; this.state.dungeon.keys[' '] = true;
            }
        }
    },

    handleTouchMove(e) {
        e.preventDefault(); const touchState = this.state.dungeon.touch;
        if (touchState.joystickId === null) return;
        for (const touch of e.changedTouches) {
            if (touch.identifier === touchState.joystickId) {
                const deltaX = touch.clientX - touchState.joystickBasePos.x; const deltaY = touch.clientY - touchState.joystickBasePos.y;
                const distance = Math.min(touchState.joystickMaxDist, Math.sqrt(deltaX**2 + deltaY**2));
                const angle = Math.atan2(deltaY, deltaX);
                const moveX = Math.cos(angle) * distance; const moveY = Math.sin(angle) * distance;
                this.elements.joystickStick.style.transform = `translate(${moveX}px, ${moveY}px)`;
                const keys = this.state.dungeon.keys;
                keys['w'] = keys['arrowup'] = deltaY < -touchState.joystickMaxDist * 0.3;
                keys['s'] = keys['arrowdown'] = deltaY > touchState.joystickMaxDist * 0.3;
                keys['a'] = keys['arrowleft'] = deltaX < -touchState.joystickMaxDist * 0.3;
                keys['d'] = keys['arrowright'] = deltaX > touchState.joystickMaxDist * 0.3;
            }
        }
    },
    
    handleTouchEnd(e) {
        const touchState = this.state.dungeon.touch;
        for (const touch of e.changedTouches) {
            if (touch.identifier === touchState.joystickId) {
                touchState.joystickId = null; this.elements.joystickStick.style.transform = `translate(0px, 0px)`;
                Object.keys(this.state.dungeon.keys).forEach(k => this.state.dungeon.keys[k] = false);
            }
            if (touch.identifier === touchState.attackId) {
                touchState.attackId = null; this.state.dungeon.keys[' '] = false;
            }
        }
    },

    runAutoProduction() {
        const soulPowerBonus = 1 + (this.state.permanent.upgrades.find(u => u.id === 'soul-power').level * 0.1);
        const baseDps = this.state.clicker.upgrades.reduce((sum, upg) => sum + upg.level * upg.dps, 0);
        this.state.clicker.money += (baseDps * soulPowerBonus) / 10;
        this.updateAllDisplays();
    },

    buyUpgrade(event, type) {
        if (event.target.tagName !== 'BUTTON') return;
        const id = event.target.dataset.id; const c = this.state.clicker; const p = this.state.permanent;
        if (type === 'automation') {
            const upg = c.upgrades.find(u => u.id === id);
            if (c.money >= upg.cost) { c.money -= upg.cost; upg.level++; upg.cost = Math.ceil(upg.cost * 1.25); }
        } else if (type === 'equipment') {
            const item = c.equipment[id];
            if (c.money >= item.cost) {
                c.money -= item.cost; item.level++; item.cost = Math.ceil(item.cost * 1.8);
                if (id === 'weapon') item.attack = Math.floor(item.attack * 1.5);
                if (id === 'armor') item.maxHp = Math.floor(item.maxHp * 1.5);
                if (id === 'boots') item.speed = parseFloat((item.speed * 1.1).toFixed(1));
            }
        } else if (type === 'soul') {
            const upg = p.upgrades.find(u => u.id === id);
            if (p.soul >= upg.cost) {
                p.soul -= upg.cost; upg.level++; upg.cost = Math.ceil(upg.cost * 1.5);
                if (upg.id === 'starting-gold') c.money += upg.effect;
            }
        }
        this.updateAllDisplays();
    },

    enterDungeon() {
        this.elements.clickerView.style.display = 'none'; this.elements.dungeonOverlay.style.display = 'flex';
        this.elements.virtualControls.classList.add('active');
        const d = this.state.dungeon;
        d.isActive = true; d.isFloorCleared = false; d.isBossFloor = false;
        d.floor = this.state.permanent.nextFloorToChallenge; d.loot = 0; d.keys = {};
        d.projectiles = []; d.hazards = []; d.bombSpawnTimer = 180;
        
        const warriorSpiritBonus = 1 + (this.state.permanent.upgrades.find(u => u.id === 'warrior-spirit').level * 0.3); // 30%
        d.player = { 
            x: 400, y: 500, size: 20, speed: this.state.clicker.equipment.boots.speed, 
            maxHp: this.state.clicker.equipment.armor.maxHp, hp: this.state.clicker.equipment.armor.maxHp, 
            attack: this.state.clicker.equipment.weapon.attack * warriorSpiritBonus, 
            isAttacking: false, attackTimer: 0, attackHitbox: null 
        };
        this.generateFloor();
        window.addEventListener('keydown', e => this.state.dungeon.keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => this.state.dungeon.keys[e.key.toLowerCase()] = false);
        d.loopId = requestAnimationFrame(this.dungeonLoop.bind(this));
    },

    generateFloor() {
        const d = this.state.dungeon; d.enemies = [];
        if (d.floor === 10) {
            d.isBossFloor = true;
            d.enemies.push({ isBoss: true, type: 'boss', x: 400, y: 150, size: 80, speed: 0.8,
                hp: 5000, maxHp: 5000, attack: 150, hitCooldown: 0, gold: 1000, spawnTimer: 300 });
            return;
        }
        const numEnemies = Math.min(10, 2 + d.floor);
        for (let i = 0; i < numEnemies; i++) {
            const isRanged = d.floor >= 4 && Math.random() < 0.4;
            d.enemies.push({
                type: isRanged ? 'ranged' : 'melee',
                x: Math.random() * 750 + 25, y: Math.random() * 300 + 25,
                size: 15 + Math.random() * 10, speed: 0.8 + d.floor * 0.1,
                hp: Math.ceil(30 * Math.pow(1.4, d.floor - 1)), maxHp: Math.ceil(30 * Math.pow(1.4, d.floor - 1)),
                attack: Math.ceil(8 * Math.pow(1.3, d.floor - 1)), hitCooldown: 0, gold: 1 + Math.floor(d.floor * 2),
                shootCooldown: isRanged ? 120 : 0
            });
        }
    },

    dungeonLoop() { if (!this.state.dungeon.isActive) return; this.updateDungeonState(); this.drawDungeon(); this.state.dungeon.loopId = requestAnimationFrame(this.dungeonLoop.bind(this)); },
    updateDungeonState() {
        const d = this.state.dungeon; if (d.isFloorCleared) return; const p = d.player;
        if (d.keys['w'] || d.keys['arrowup']) p.y -= p.speed; if (d.keys['s'] || d.keys['arrowdown']) p.y += p.speed;
        if (d.keys['a'] || d.keys['arrowleft']) p.x -= p.speed; if (d.keys['d'] || d.keys['arrowright']) p.x += p.speed;
        p.x = Math.max(p.size, Math.min(this.elements.canvas.width - p.size, p.x));
        p.y = Math.max(p.size, Math.min(this.elements.canvas.height - p.size, p.y));
        if (p.attackTimer > 0) p.attackTimer--;
        if (d.keys[' '] && p.attackTimer === 0) { p.isAttacking = true; p.attackTimer = 30; p.attackHitbox = { x: p.x, y: p.y, size: 60 }; } 
        else if (p.attackTimer < 15) { p.isAttacking = false; p.attackHitbox = null; }
        
        this.updateEnemies(); this.updateProjectiles(); this.updateHazards();

        const deadEnemies = d.enemies.filter(e => e.hp <= 0);
        deadEnemies.forEach(de => { d.loot += de.gold; if (de.isBoss) d.isFloorCleared = true; });
        d.enemies = d.enemies.filter(e => e.hp > 0);
        
        if (d.enemies.length === 0 && !d.isFloorCleared) {
            d.isFloorCleared = true; d.loot += 100 * d.floor; this.handleFloorClear();
        } else if (d.isBossFloor && d.isFloorCleared) { this.handleFloorClear(); }
    },
    
    updateEnemies() {
        const d = this.state.dungeon, p = d.player;
        d.enemies.forEach(e => {
            if (e.hitCooldown > 0) e.hitCooldown--;
            const dx = p.x - e.x, dy = p.y - e.y, dist = Math.sqrt(dx**2 + dy**2);

            if (e.type === 'melee' || e.type === 'minion') { if (dist > p.size) { e.x += (dx / dist) * e.speed; e.y += (dy / dist) * e.speed; } }
            else if (e.type === 'ranged') {
                if (dist > 200) { e.x += (dx / dist) * e.speed; e.y += (dy / dist) * e.speed; }
                if (e.shootCooldown > 0) e.shootCooldown--;
                else {
                    d.projectiles.push({ x: e.x, y: e.y, size: 5, vx: dx / dist * 4, vy: dy / dist * 4, damage: e.attack });
                    e.shootCooldown = 120 - d.floor * 2;
                }
            } else if (e.isBoss) {
                if (dist > 100) { e.x += (dx / dist) * e.speed; e.y += (dy / dist) * e.speed; }
                if (e.spawnTimer > 0) e.spawnTimer--;
                else {
                    d.enemies.push({ type: 'minion', x: e.x, y: e.y, size: 15, speed: 1.5, hp: 100, maxHp: 100, attack: 20, hitCooldown: 0, gold: 5 });
                    e.spawnTimer = 400 - d.floor * 10;
                }
            }

            if (p.attackHitbox && this.isColliding(p.attackHitbox, e)) { e.hp -= p.attack; p.attackHitbox = null; }
            if (dist < p.size/2 + e.size/2 && e.hitCooldown === 0) {
                p.hp -= e.attack; e.hitCooldown = 120;
                if (p.hp <= 0) { this.handlePlayerDeath(); return; }
            }
        });
    },

    updateProjectiles() {
        const d = this.state.dungeon, p = d.player, canvas = this.elements.canvas;
        d.projectiles.forEach(proj => {
            proj.x += proj.vx; proj.y += proj.vy;
            if (this.isColliding(proj, p)) {
                p.hp -= proj.damage; proj.hp = 0; // Mark for removal
                if (p.hp <= 0) this.handlePlayerDeath();
            } else if (proj.x < 0 || proj.x > canvas.width || proj.y < 0 || proj.y > canvas.height) {
                proj.hp = 0;
            }
        });
        d.projectiles = d.projectiles.filter(proj => proj.hp !== 0);
    },

    updateHazards() {
        const d = this.state.dungeon, p = d.player, canvas = this.elements.canvas;
        if (d.floor >= 7 && !d.isBossFloor) {
            if (d.bombSpawnTimer > 0) d.bombSpawnTimer--;
            else {
                d.hazards.push({ type: 'bomb', x: Math.random() * canvas.width, y: Math.random() * canvas.height, size: 20, timer: 120 });
                d.bombSpawnTimer = 240 - d.floor * 5;
            }
        }
        d.hazards.forEach(h => {
            if (h.type === 'bomb') {
                h.timer--;
                if (h.timer <= 0) {
                    h.type = 'explosion'; h.size = 80; h.life = 30; // Mark for removal next frame
                }
            } else if (h.type === 'explosion') {
                if (h.life === 30 && this.isColliding(h, p)) p.hp -= 50 * d.floor;
                h.life--;
                if (p.hp <= 0) this.handlePlayerDeath();
            }
        });
        d.hazards = d.hazards.filter(h => h.life !== 0);
    },
    
    isColliding(c1, c2) { const dist = Math.sqrt((c1.x - c2.x)**2 + (c1.y - c2.y)**2); return dist < (c1.size / 2 + c2.size / 2); },

    drawDungeon() {
        const ctx = this.ctx, canvas = this.elements.canvas, d = this.state.dungeon;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        d.hazards.forEach(h => {
            if (h.type === 'bomb') {
                ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
                ctx.beginPath(); ctx.arc(h.x, h.y, h.size, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = 'white'; ctx.fillText(Math.ceil(h.timer / 60), h.x, h.y);
            } else if (h.type === 'explosion') {
                ctx.fillStyle = `rgba(255, 100, 0, ${h.life / 30})`;
                ctx.beginPath(); ctx.arc(h.x, h.y, h.size, 0, Math.PI * 2); ctx.fill();
            }
        });
        d.projectiles.forEach(proj => { ctx.fillStyle = '#ffeb3b'; ctx.beginPath(); ctx.arc(proj.x, proj.y, proj.size, 0, Math.PI * 2); ctx.fill(); });
        d.enemies.forEach(e => {
            ctx.fillStyle = e.isBoss ? '#512DA8' : (e.type === 'ranged' ? '#1E88E5' : '#c0392b');
            if (e.hitCooldown > 0) ctx.fillStyle = '#e74c3c';
            ctx.fillRect(e.x - e.size / 2, e.y - e.size / 2, e.size, e.size);
            ctx.fillStyle = '#555'; ctx.fillRect(e.x - e.size/2, e.y - e.size/2 - 10, e.size, 5);
            ctx.fillStyle = 'red'; ctx.fillRect(e.x - e.size/2, e.y - e.size/2 - 10, e.size * (e.hp / e.maxHp), 5);
        });
        const p = d.player;
        ctx.fillStyle = '#3498db'; ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
        if (p.isAttacking) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.beginPath(); ctx.arc(p.x, p.y, 30, 0, Math.PI * 2); ctx.fill();
        }
        this.elements.floorDisplay.textContent = d.floor; this.elements.lootDisplay.textContent = d.loot.toLocaleString();
        this.elements.playerHpBar.style.width = `${Math.max(0, p.hp / p.maxHp) * 100}%`;
    },
    
    handleFloorClear() {
        cancelAnimationFrame(this.state.dungeon.loopId); this.state.dungeon.isActive = false;
        if (this.state.dungeon.isBossFloor) this.state.permanent.bossHearts++;
        this.elements.clearLootDisplay.textContent = this.state.dungeon.loot.toLocaleString();
        this.elements.floorClearMessage.style.display = 'block';
    },

    exitDungeonSafely() {
        this.elements.virtualControls.classList.remove('active');
        this.state.clicker.money += this.state.dungeon.loot;
        if (this.state.permanent.nextFloorToChallenge <= 10) this.state.permanent.nextFloorToChallenge++;
        this.saveGame();
        this.elements.floorClearMessage.style.display = 'none';
        this.elements.dungeonOverlay.style.display = 'none'; this.elements.clickerView.style.display = 'block';
        this.updateAllDisplays();
    },

    handlePlayerDeath() {
        this.elements.virtualControls.classList.remove('active');
        cancelAnimationFrame(this.state.dungeon.loopId); this.state.dungeon.isActive = false;
        const floor = this.state.dungeon.floor;
        const earnedSouls = floor > 1 ? floor - 1 : 0;
        this.elements.earnedSoulDisplay.textContent = earnedSouls;
        this.elements.deathMessage.style.display = 'block';
        setTimeout(() => this.reincarnate(earnedSouls), 3000);
    },

    reincarnate(earnedSouls) {
        this.state.permanent.soul += earnedSouls;
        this.state.permanent.nextFloorToChallenge = 1;
        this.resetTemporaryState();
        const startingGoldUpg = this.state.permanent.upgrades.find(u => u.id === 'starting-gold');
        this.state.clicker.money += startingGoldUpg.level * startingGoldUpg.effect;
        this.saveGame();
        this.elements.deathMessage.style.display = 'none';
        this.elements.dungeonOverlay.style.display = 'none'; this.elements.clickerView.style.display = 'block';
        this.buildShops();
        this.updateAllDisplays();
    },

    updateAllDisplays() {
        const p = this.state.permanent; const c = this.state.clicker;
        const soulPowerBonus = 1 + (p.upgrades.find(u => u.id === 'soul-power').level * 0.1);
        const baseDps = c.upgrades.reduce((sum, upg) => sum + upg.level * upg.dps, 0);
        this.elements.moneyDisplay.textContent = Math.floor(c.money).toLocaleString();
        this.elements.dpsDisplay.textContent = Math.floor(baseDps * soulPowerBonus).toLocaleString();
        this.elements.soulDisplay.textContent = p.soul.toLocaleString();
        this.elements.bossHeartDisplay.textContent = p.bossHearts.toLocaleString();
        c.upgrades.forEach(upg => {
            document.getElementById(`${upg.id}-level`).textContent = upg.level;
            document.getElementById(`${upg.id}-cost`).textContent = Math.ceil(upg.cost).toLocaleString();
            document.querySelector(`[data-id="${upg.id}"].automation-btn`).disabled = c.money < upg.cost;
        });
        const { weapon, armor, boots } = c.equipment;
        document.getElementById('weapon-level').textContent = weapon.level;
        document.getElementById('weapon-cost').textContent = weapon.cost.toLocaleString();
        document.getElementById('weapon-desc').textContent = `공격력: ${weapon.attack}`;
        document.querySelector('[data-id="weapon"].equipment-btn').disabled = c.money < weapon.cost;
        document.getElementById('armor-level').textContent = armor.level;
        document.getElementById('armor-cost').textContent = armor.cost.toLocaleString();
        document.getElementById('armor-desc').textContent = `최대 HP: ${armor.maxHp}`;
        document.querySelector('[data-id="armor"].equipment-btn').disabled = c.money < armor.cost;
        document.getElementById('boots-level').textContent = boots.level;
        document.getElementById('boots-cost').textContent = boots.cost.toLocaleString();
        document.getElementById('boots-desc').textContent = `이동속도: ${boots.speed.toFixed(1)}`;
        document.querySelector('[data-id="boots"].equipment-btn').disabled = c.money < boots.cost;
        p.upgrades.forEach(upg => {
            document.getElementById(`${upg.id}-level`).textContent = upg.level;
            document.getElementById(`${upg.id}-cost`).textContent = Math.ceil(upg.cost).toLocaleString();
            document.querySelector(`[data-id="${upg.id}"].soul-btn`).disabled = p.soul < upg.cost;
        });
        this.elements.nextFloorDisplay.textContent = p.nextFloorToChallenge > 10 ? 'MAX' : `${p.nextFloorToChallenge}층`;
        this.elements.enterDungeonBtn.disabled = p.nextFloorToChallenge > 10;
    },

    saveGame() { localStorage.setItem('bossClickerState', JSON.stringify(this.state.permanent)); },
    loadGame() {
        const savedState = localStorage.getItem('bossClickerState');
        if (savedState) {
            const loaded = JSON.parse(savedState);
            this.state.permanent.soul = loaded.soul || 0;
            this.state.permanent.nextFloorToChallenge = loaded.nextFloorToChallenge || 1;
            this.state.permanent.bossHearts = loaded.bossHearts || 0;
            this.state.permanent.upgrades.forEach(upg => {
                const loadedUpg = loaded.upgrades.find(u => u.id === upg.id); if (loadedUpg) Object.assign(upg, loadedUpg);
            });
            const startingGoldUpg = this.state.permanent.upgrades.find(u => u.id === 'starting-gold');
            this.state.clicker.money += startingGoldUpg.level * startingGoldUpg.effect;
        }
    },
};
game.init();
</script>
</body>
</html>
